把Github上一个非常经典的开源项目，封装成一个Skill，方便我们以后进行调用
chapter1-page1：
互联网发展三十年来最宝贵的遗产之一：开源协作生态。从操作系统（Linux）、编程语言（Python、JavaScript）、数据库（MySQL）、前端框架（React）到各种开发工具和基础设施（Docker， Kubernetes），无数顶尖开发者将智慧结晶开源，极大地降低了技术门槛，加速了全球创新。
chapter1-page2：
在绝大多数通用、常规的需求场景下，“重复造轮子”是低效且不明智的。这个观点在工程领域非常正确：
时间成本：从零开始实现一个成熟开源项目已有的功能，需要漫长的开发、测试和优化周期。
质量差距：经过社区千锤百炼、被广泛使用的开源项目，在健壮性、安全性、性能上往往远胜个人或小团队闭门造车的成果。
生态缺失：成熟的开源项目通常有丰富的文档、社区支持和第三方插件，这是新轮子无法比拟的。
chapter1-page3：
核心思想是“优先复用，谨慎自研”。这是一种现代软件工程的最佳实践：
先搜索调研：看看是否有现成的、可维护的、有活跃社区的开源方案。
评估适配度：是否满足了核心需求的80%以上？是否符合技术栈？许可证是否兼容？
考虑二次开发：在开源基础上进行定制或扩展，往往比从头开始更高效。
chapter1-page4
但也有一些例外场景，让“造轮子”有其价值：
极端个性化需求：当业务需求极其特殊，现有方案都无法较好满足，且改动成本高于重写时。
追求极致性能/控制：如大型科技公司为特定场景自研数据库、框架（如Google的MapReduce），为了获得完全的技术控制权和优化空间。
学习与教育目的：为了深入理解某个领域或技术原理，“造轮子”是最好的学习途径之一。
避免“供应链”风险：过度依赖单一开源项目可能存在维护停滞、许可证变更或安全漏洞风险，有时需要自主可控的备选方案。
chapter1-page5
在现实中，优秀的工程师和架构师正是这样做的：
默认优先选择成熟的、社区认可的开源方案。
在确实需要自研时，清晰地知道“为什么不能直接用开源方案”，并有充分的理由。
即使自研，也会大量参考开源项目的设计和实现，避免闭门造车。
chapter1-page6
在开源世界如此丰富的今天，工程师的核心价值不再仅仅是“写代码实现功能”，而更多是“在浩瀚的开源生态中，做出明智的选择、高效的集成和创造性的组合，以解决实际问题”。
这是一种更高级的能力。

chapter2-page1
很多“格式工厂”“压缩神器”类的商业工具，背后就是开源项目的集成与包装，尤其是一些处理文件转换、格式转换、数据压缩、视频剪辑、屏幕录制等功能的工具型应用。
chapter2-page2
1. 技术来源：开源工具套壳
很多这类应用的核心处理功能（比如视频转码、文件解压缩、图片格式转换等）其实都基于知名的开源项目，例如：
FFmpeg：处理音视频编解码、转码、剪辑等
ImageMagick：图片格式转换、大小调整
7-Zip（7z）、zlib等：文件压缩与解压
Pandoc：文档格式转换
各种 PDF 处理库
chapter2-page3
2. 模式逻辑
省去了开发核心技术的成本：
 自己开发成熟的编解码、格式解析等底层技术门槛高，而且容易有兼容性、法律风险。
专注在前端和体验：
 用简洁的UI/UX把这些技术包装成“傻瓜式”服务，让用户点几下就能用。
商业模式：
 大多数这样的工具可能采取“免费使用+广告/会员增值服务”的模式。比如免费有限次数/有水印，付费解锁批量、高速、去广告、无水印等。
chapter2-page4
3. 问题与风险
同质化严重：
 当大家都用同样的底层开源工具，功能上大同小异，主要靠界面、服务稳定性和价格竞争。
可能“割韭菜”：
 有些会夸大功能宣传，或利用小白的“技术焦虑”收费，而实际上你甚至可以找到免费的原版开源工具手动操作。
安全隐患：
 有些壳应用会偷偷加广告、捆绑安装、甚至窃取用户文件，毕竟你上传了文件，服务端怎么处理你并不知道。
版权和开源协议问题：
 绝大多数开源工具允许商用，但必须遵守对应开源协议（如GPL、MIT等），有些商业应用可能未合规标注来源或开放源代码，存在法律风险。
chapter2-page5
4. 用户应该怎么做？
辨别真伪：看它是否过于夸大，并了解背后可能是什么开源工具在支持。
纵向比较：如果是高频需求，可以考虑购买正版的、口碑好的专业软件；如果是偶尔使用，网上有很多免费在线工具（很多也是基于开源），不必下载安装一个独立APP。
学点技术：
 如果某些功能用得很频繁，可以学学怎样自己用原版开源工具，虽然要输入命令，但更灵活，而且可以自定义。

chapter3-page1
开源软件领域一个普遍存在且关键的 “可用性鸿沟” 。
chapter3-page2
核心问题：“可用性鸿沟”或“用户门槛”
你提到的“环境”和“命令行操作”，正是这道鸿沟的核心体现。它的本质是：
目标用户错位：项目的开发者和核心贡献者通常是开发者、系统管理员或研究人员。他们习惯命令行、依赖管理、调试环境问题。因此，他们构建的工具天然地服务于自己的同类。
产品思维缺失：很多出色的开源项目是“工具”（Tool）或“库”（Library），而非“产品”（Product）。作为一个产品，需要考虑安装、配置、交互、错误处理等完整的用户体验链条。而很多开源项目只专注于解决核心的技术问题（功能），而忽略了“让普通人能用”这个环节。
chapter3-page3
两个难点之一：“光环境这一条，就能卡死绝大多数的普通用户”
依赖地狱：需要安装特定版本的 Python、Node.js、Java，或者各种系统库（如  libssl 、 libxxx-dev ）。缺失或版本不对就报错。
配置复杂：需要修改配置文件（如  .yaml ,  .json ,  .env ），设置数据库连接、API密钥、路径等。对普通用户来说如同天书。
系统兼容性：可能在 macOS 上很顺利，在 Windows 上就困难重重，反之亦然。
网络问题：从 GitHub、PyPI、npm 等拉取依赖时，可能因为网络超时或中断而失败。 这整个过程没有清晰的指引、一键式的安装程序或友好的错误提示，普通用户的第一步就失败了。
chapter3-page4
两个难点之二：“部署以后还是用命令行操作”
交互不直观：命令行需要记忆命令、参数、选项（ --help  输出的内容可能也很晦涩）。而 GUI 可以通过点击、拖拽、表单填写来完成。
结果呈现不友好：输出可能是密密麻麻的日志、JSON 数据或纯文本，需要用户自己解析和理解。GUI 可以提供表格、图表、可视化结果。
缺乏状态感和引导：命令行是线性的，用户可能不知道进行到哪一步了，或者下一步该做什么。GUI 可以通过进度条、向导、菜单结构来引导用户。
chapter3-page5
为什么会这样？深层原因在于
开发资源有限：开源团队的核心精力在于维护核心功能、修复 Bug、增加新特性。开发一个稳定、跨平台的 GUI 需要巨大的前端/客户端工程投入，这往往是志愿团队无法承担的。
社区文化：在开发者社区，命令行往往被视为更强大、更灵活、更“专业”的工具。为“普通用户”开发 GUI 有时甚至会被部分社区成员认为“不酷”或“偏离技术本质”。
抽象层级不同：命令行工具通常作为基础组件，旨在被其他开发者集成或自动化。它的 API（命令行接口）本身就是一种设计。而 GUI 是面向最终用户的另一层抽象。
分发和更新的挑战：GUI 应用（尤其是桌面端）的分发（打包成  .exe 、 .dmg 、 .deb  等）、安装和自动更新，本身就是一套复杂的工程体系。
chapter3-page6
趋势和解决方案——尽管存在鸿沟，但情况正在改善：
容器化：Docker 完美地解决了“环境”问题。一个好的开源项目提供  docker-compose.yml ，用户只需  docker-compose up -d  就能一键启动所有服务，极大地降低了部署门槛。
提供 Web UI：越来越多的后端/命令行工具开始配套一个轻量的 Web 管理界面（例如，Home Assistant, Portainer, Jenkins）。这比开发原生桌面 GUI 更简单（基于浏览器），也更易于部署。
社区衍生产品：有时，第三方开发者或商业公司会基于热门的开源核心，开发友好的 GUI 封装或 SaaS 服务。例如，很多 AI 模型都有社区开发的图形界面。
更好的文档和安装脚本：提供清晰的安装向导、一键安装脚本（如  install.sh ）或详细的排错指南。
商业开源模式：一些项目通过提供免费的、功能完备的命令行核心+付费的易于使用的云服务或企业 GUI 版本来养活自己，并反哺社区。
chapter3-page7
开源软件从 “极客玩具” 走向 “大众产品” 过程中的关键障碍。技术上的优越性，并不等同于市场上的可获得性。
一个项目的真正影响力，不仅在于其代码有多棒，还在于它能让多少人方便地用起来。能跨越这条鸿沟的项目（如 VS Code、Home Assistant、Bitwarden 等），往往都获得了巨大的成功和广泛的用户基础。
所以，如果你发现一个很棒的开源项目没有 GUI，这很“正常”，但同时也可能是一个机会——为它贡献一个 Web 前端、改进它的安装文档，或者写一篇更通俗的教程，都是在弥合这道数字鸿沟，非常有价值。

chapter4-page1
从 Github 开源项目到 Agent Skills
chapter4-page2
Skills 是一种能将 脚本代码 和 自然语言指令（Prompt） 打包在一起的技术单元。
这种结构上的独特性，使其比单一的Prompt或孤立的脚本更强大、更易用，尤其适合与当前强大的代码生成大模型（基模）和智能体结合。
它的关键价值和潜力在于：能高效地将开源社区的优秀项目“技能化”，变成智能体可以直接调用的标准化模块。
chapter4-page3
Skills 是什么？
定义：一个可复用的功能包，包含两部分： 
核心逻辑代码（脚本）：实现具体功能的程序。

调用说明书（Prompt）：告诉AI（智能体）什么时候使用它、如何使用它、需要什么输入、会有什么输出。
类比：就像微信的“小程序”，既是一个独立的程序（脚本），又有一个标准的调用入口和描述（Prompt），可以方便地被微信（智能体平台）发现和运行。
chapter4-page4
对比“单Prompt”或“单一脚本”
单Prompt：只告诉AI做什么，但不提供怎么做的能力（在复杂或专业任务中，仅靠AI生成代码可能不可靠或效率低）。
单一脚本：虽然解决了“怎么做”，但AI无法智能判断何时应该调用它，需要硬编码或人类手动触发。
Skills：融合了两者。它既提供了可靠、高效的执行代码（脚本），又通过Prompt赋予了AI调用和理解它的“心智”。这让AI能像人一样，根据任务需求，“思考”并“选择”调用合适的技能。
chapter4-page5
与“强大的基模和Agent”的结合
代码能力强的大模型：可以直接理解、生成、甚至修改Skill中的代码，使其开发、测试、部署变得非常高效。
智能体平台：可以成为Skills的“操作系统”或“应用商店”。智能体可以根据用户的目标，自动规划、选择、组合并使用不同的Skills来完成任务。
chapter4-page6
核心潜力：将开源项目“Skill化”
现状：GitHub等平台上有海量高质量的开源项目（例如数据爬虫、图像处理、金融分析等工具），但它们是为人类开发者设计的。
“Skill化”过程：为这些项目封装一层统一的接口，并编写一个能让AI理解的Prompt描述。
结果：一个原本复杂的开源工具，被包装成了一个“即插即用”的AI技能。任何拥有此Skills库的智能体，都能直接“学会”并使用这个工具，无需从头训练。
意义：这相当于为AI智能体建立了一个庞大的、可扩展的“技能生态”。AI的能力边界不再仅受限于其训练数据，而是可以通过集成人类已有的所有代码工具来无限扩展。
chapter4-page7
通俗比喻——想象一下：
你（用户） 是公司的CEO。
AI智能体 是你的全能私人助理。
Skills 就是你为助理雇的各种“外部专家团队”。 
以前，助理只能靠自己学到的知识（模型训练数据）来做事，能力有限。
现在，你可以轻松地为助理配上一个财务分析Skill（封装了开源量化分析库）、一个设计Skill（封装了开源图像生成模型）、一个市场调研Skill（封装了爬虫工具）……
当你对助理说：“帮我分析一下最近的财报，做一份漂亮的趋势图，并爬取竞品数据。”助理会自动、有逻辑地调用这三个Skills，高效完成任务。
chapter4-page8
Skills是连接人类智慧结晶（代码）与AI自主行动（智能体）的关键桥梁。
它能让AI真正“站在巨人的肩膀上”，利用整个开源世界的力量来为我们服务。
这是一种极具前景的AI应用范式。

chapter5-page1
一种尝试：“我把视频处理的开源项目FFmpeg和图片视频处理项目ImageMagick，封装成了一个多模态素材处理的Skill。”

chapter6-page1
AI正是弥合顶尖开源技术与普通大众之间鸿沟的“万能翻译器”和“超级执行层”。
chapter6-page2
技术应用的“知识壁垒”
核心洞察：GitHub是开发者的宝藏，但使用它需要一系列专业知识：知道GitHub的存在、会用Git搜索、能看懂README、理解技术栈、会配置环境、能跑通代码……这对普通人来说是一堵高墙。
传统解决方案：需要开发者充当“中介”，把开源项目封装成傻瓜软件（.exe/.dmg）、手机App或在线服务（SaaS），才能交付给大众。这个过程就是“封装成Skill”，但成本高、速度慢。
chapter6-page3
“ 思考两分钟后的顿悟”：AI如何颠覆这个链条
“不对啊，这不都有AI了吗”，其背后的逻辑链条，正是当前AI Agents和AI应用发展的核心方向：
那么，AI 如何解决“普通人不知GitHub”的问题？
chapter6-page4
需求翻译器：
过去：普通人需要把需求（“我想把这张照片的背景换成海滩”）翻译成技术关键词（“AI 去背景 开源工具 remove background GitHub”），然后自己去搜索、尝试。
现在/未来：普通人只需用自然语言描述需求。AI理解后，在后台自动完成“技术关键词生成 -> 搜索已知开源方案 -> 选择最合适工具”的全过程。用户完全不需要知道工具叫什么、在哪。
chapter6-page5
执行与集成器：
AI可以作为一个“智能外壳”，直接调用最合适的开源工具（或它们的API）。
例如：用户说“帮我分析一下这个Excel表格，总结出销售趋势并生成图表”。AI背后可能自动调用了  pandas （数据分析）、 matplotlib （绘图）等多个开源库，并编写了必要的代码来串联它们，最后把结果以图文形式呈现给用户。用户全程接触的是对话，而非代码。
chapter6-page6
去封装化与动态化：
传统“封装”：是静态的、固定的。一个App的功能在发布时就确定了。
AI驱动的“Skill”：是动态的、按需组合的。AI就像一个拥有海量“开源工具卡”的超级管家，用户每提出一个新需求，AI就现场挑选并组合几张“卡”来完成任务。“封装”这个动作从开发者的前期工作，变成了AI的实时响应。
chapter6-page7
这具体是如何发生的？——技术实现层面 01
基础层：AI会写代码，AI可以理解需求，并直接生成调用相关开源库的代码。这本身就是一种“自动封装”。
chapter6-page8
这具体是如何发生的？——技术实现层面 02
进阶层：AI智能体（AI Agents） AI不仅能写代码，还能规划步骤、使用工具（Tool Use）。例如：
用户说：“从这份PDF合同里提取所有日期和金额，做成一个表格。”
AI智能体自主规划： 步骤1：用 pypdf2 或 pdfplumber 解析PDF -> 步骤2：用正则表达式或 spacy 找日期和金额 -> 步骤3：用 pandas 生成表格 -> 步骤4：用 openpyxl 保存为Excel文件或直接在聊天框展示 。
它在后台自动或半自动地执行了这个流程。
chapter6-page9
这具体是如何发生的？——技术实现层面 03
产品层：AI-Native应用 很多新应用将开源能力作为“引擎”，把AI作为“交互界面”和“调度中枢”。比如：
ChatGPT的“高级数据分析”：本质上是给对话赋予了调用Python及数据科学库的能力。
各类AI图像生成/编辑工具：背后是 Stable Diffusion 等开源模型，但用户通过提示词和点按来操作。
未来的“超级助手”：可能会内置一个“工具库”，涵盖文本、图像、视频、数据分析、自动化等各领域最优秀的开源项目，用户通过对话即可驱使。
chapter6-page10
未来的趋势——AI正在让“封装”变得：
自动化：无需开发者手动为每个功能写集成代码，AI可以按需生成。
民主化：使用技术的门槛从“懂编程、懂GitHub”降低到“会描述问题”。
无形化：最好的技术是让人感觉不到技术的存在。开源项目和复杂工具将像水电一样，成为AI背后看不见的基础设施。
chapter6-page11
所以，对于普通大众来说，他们未来真的不需要知道GitHub是什么。
他们只需要有一个足够强大的AI助手，能够理解他们的意图，并代表他们去调度和指挥背后浩如烟海的开源技术资源。
这不仅仅是解决问题，这正在重新定义“解决问题”的方式本身。 

chapter7-page1
从需求到固化技能：AI 辅助将 yt-dlp 封装为可靠 Agent Skill 全流程指南
chapter7-page2
在 AI 时代，将成熟的开源工具封装为智能体（Agent）的即插即用技能（Skill），是提升个人效率、构建专属数字工具箱的核心方法论。
本教程将详细拆解如何将一个通用的视频下载需求，通过 AI 辅助，最终固化为一个稳定、高效的视频下载 Skill 的全过程。
chapter7-page3
第一阶段：需求分析与开源项目发现
核心思想：站在巨人的肩膀上，你的需求绝非孤例。 互联网发展数十年，绝大多数通用需求都有前辈用开源项目提供了优雅的解决方案。
明确需求：首先清晰定义你的目标，例如“需要一个能从 YouTube、B站等视频网站下载视频的工具”。
chapter7-page4
第一阶段：需求分析与开源项目发现
核心思想：站在巨人的肩膀上，你的需求绝非孤例。 互联网发展数十年，绝大多数通用需求都有前辈用开源项目提供了优雅的解决方案。
AI 辅助搜索：使用具备强大搜索能力的 AI 模型（如 GPT-5.2 Thinking）作为你的“项目发现助手”。直接向其提出你的需求：“有没有那种就是去各种视频网站上，下载视频，比如 Youtube、B站等等的 github 上的开源项目。”
chapter7-page5
第一阶段：需求分析与开源项目发现
核心思想：站在巨人的肩膀上，你的需求绝非孤例。 互联网发展数十年，绝大多数通用需求都有前辈用开源项目提供了优雅的解决方案。
锁定目标：AI 通常会推荐在 GitHub 上拥有超过 143k Star、被誉为“封神”级别的项目——yt-dlp。它是 youtube-dl 的现代化分支，支持上千个网站，功能极其强大，涵盖了从基础下载到高级格式选择、字幕获取、元数据嵌入等所有功能。
chapter7-page6
第二阶段：技能规划与封装
核心思想：使用专业工具（skill-creator），将项目代码转化为可被 Agent 理解的技能包。 手动阅读文档和代码耗时耗力，自动化封装工具是关键。

准备环境：确保你使用的 AI 开发环境（如 Claude Code、OpenCode）已安装官方提供的 skill-creator 技能。这个技能专门用于将开源项目打包成 Skill。
chapter7-page7
第二阶段：技能规划与封装
核心思想：使用专业工具（skill-creator），将项目代码转化为可被 Agent 理解的技能包。 手动阅读文档和代码耗时耗力，自动化封装工具是关键。
启动规划模式：在与 AI 的对话中，开启“Plan”模式。这是一个至关重要的步骤，它让 AI 在动手前先进行整体分析和规划，确保后续开发路线清晰，成功率更高。输入指令：“帮我把这个开源工具 https://github.com/yt-dlp/yt-dlp 打包成一个 Skill，只要我后续给出视频链接，就可以帮我下载视频。”
chapter7-page8
第二阶段：技能规划与封装
核心思想：使用专业工具（skill-creator），将项目代码转化为可被 Agent 理解的技能包。 手动阅读文档和代码耗时耗力，自动化封装工具是关键。
交互式规划：AI（通常是 Claude 4.5 Opus 等长于规划的模型）会调用 skill-creator，开始分析 yt-dlp 的仓库结构、依赖和核心用法。它会向你提出一系列问题以明确 Skill 的边界和功能，例如： 
技能的使用场景和输入输出格式是什么？（输入视频URL，输出下载好的文件）
需要包含哪些核心参数？（如下载质量  -f 、仅下载音频  -x 、下载字幕  --write-subs  等）
如何处理平台特定的限制？（如需要 Cookie 登录的 B 站高清视频） 你的回答将帮助 AI 生成一份详细的、可执行的封装计划。
chapter7-page9
第三阶段：开发执行与首次运行
核心思想：模型分工，并行调试。构建时用 Claude，首次复杂运行时用 Codex。 不同的 AI 模型在不同阶段各有所长。
切换开发模式：确认规划无误后，切换到正式的开发执行模式。对 AI 下达指令：“开始开发！” skill-creator 将根据规划，自动生成符合 Claude Skill 规范的目录结构和核心文件  skill.md 。这个文件定义了技能的描述、指令、参数和调用方式。
chapter7-page10
第三阶段：开发执行与首次运行
核心思想：模型分工，并行调试。构建时用 Claude，首次复杂运行时用 Codex。 不同的 AI 模型在不同阶段各有所长。
首次运行与问题调试：技能包生成后，进行第一次实战测试。推荐在此阶段切换至 GPT-5.2 Codex 等执行和调试能力强的模型。输入一个视频链接（例如一个 YouTube 视频地址）来调用新生成的 video-downloader Skill。
chapter7-page11
第三阶段：开发执行与首次运行
核心思想：模型分工，并行调试。构建时用 Claude，首次复杂运行时用 Codex。 不同的 AI 模型在不同阶段各有所长。
克服首次运行障碍：首次运行几乎必然会遇到环境问题，AI 会指导你逐步解决，这是技能“本地化”的关键： 
依赖安装：AI 会检查并指导你安装必要的依赖，如  ffmpeg （用于视频合并、格式转换）。
Cookie 处理：对于 B 站等需要登录才能下载高清视频的网站，AI 会指导你使用  --cookies-from-browser  参数，从 Chrome 等浏览器导出 Cookie 文件。
网络配置：如果需要，会指导你设置代理参数  --proxy 。 在 AI 的逐步指导下完成这些初始化配置后，视频成功下载。整个过程可能在几分钟内完成。
chapter7-page12
第四阶段：迭代优化与技能固化
核心思想：将实践经验反哺给技能，实现从“能用”到“好用”的进化。
经验总结与反馈：首次运行成功后，立即将整个过程中遇到的问题、解决方案和最佳实践反馈给 AI。例如：“把这些经验，都更新到 video-downloader 这个 skill 里，下次就别这么慢了。”
chapter7-page13
第四阶段：迭代优化与技能固化
核心思想：将实践经验反哺给技能，实现从“能用”到“好用”的进化。
技能迭代：AI 会根据你的反馈，自动修改和优化  skill.md  文件。它可能会将安装  ffmpeg  的步骤、获取 Cookie 的常用方法、针对 B 站和 YouTube 的推荐参数组合等，以注释、默认值或条件判断逻辑的形式，固化到技能指令中。
chapter7-page14
第四阶段：迭代优化与技能固化
核心思想：将实践经验反哺给技能，实现从“能用”到“好用”的进化。
技能固化：经过一次或多次这样的“运行-反馈-优化”循环后，你的 video-downloader Skill 变得高度成熟和稳定。它不再是一个简单的项目包装，而是一个内嵌了实战经验的智能技能。后续使用时，你只需提供视频链接，Skill 就能自动处理各种前置条件，在十几秒内触发下载。
chapter7-page15
总结：你的个性化技能工厂流水线
通过上述流程，你实践了一套可复用的方法论：需求 → AI 搜索发现 → 规划封装 → 运行调试 → 经验迭代 → 技能固化。
这标志着你的工作模式从“遇到问题，临时搜索解决”转变为“管理一个由固化技能组成的智能体团队”。
yt-dlp 只是第一个例子，你可以将这套流程应用于无数其他优秀的开源项目，无论是图像处理、文档转换、数据爬取还是自动化运维，将它们都变成你主 Agent 中随时可调用的、可靠的技能模块。
从此，整个 GitHub 的宝藏都成了你扩展个人能力的弹药库，真正实现了“三头六臂无所不能”的数字化赋能。
chapter8-page1
推荐 GitHub 开源项目及其用途：
项目名称GitHub 链接/仓库名主要用途
yt-dlp https://github.com/yt-dlp/yt-dlp 从YouTube、B站等上千个网站下载视频的命令行工具。 
FFmpeg FFmpeg/FFmpeg 强大的音视频处理库，可用于录制、转换、流媒体处理等多种功能。文章中与ImageMagick一起被封裝成“多模态素材处理Skill”。 
ImageMagick ImageMagick/ImageMagick 用于创建、编辑、合成或转换位图图像的命令行工具。文章中与FFmpeg一起被封裝成“多模态素材处理Skill”。 
Pake tw93/Pake 可以将网页（Web项目）非常轻松地打包成一个轻量级的桌面应用程序（APP）。 
ArchiveBox ArchiveBox/ArchiveBox 一个自托管的网页存档工具，可以以多种格式（如PDF，截图等）保存你想永久保留的网页内容。
Ciphey Ciphey/Ciphey 一个基于人工智能的自动化工具，用于自动解密和解码文本/密码。